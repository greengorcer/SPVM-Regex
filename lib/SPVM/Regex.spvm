class Regex {
  use Unicode;
  use List;
  use IntList;
  use Hash;
  use StringBuffer;
  use Regex::Replacer;
  use Regex::Pattern;
  use Fn;
  has patterns : List;
  has string_start : byte;
  has string_end : byte;
  has single_line_mode : byte;
  has ascii_mode : byte;
  has ignore_case : byte;
  
  has captures : ro string[];
  
  has match_start : ro int;
  has match_length : ro int;
  
  has replace_count : ro int;
  has before_is_hyphen : byte;
  has before_is_open_bracket : byte;
  
  private enum {
    QUANTIFIER_STATUS_NOT_STARTED,
    QUANTIFIER_STATUS_MIN,
    QUANTIFIER_STATUS_MAX,
  }

  native static method re2_test : void ();
  
  static method new : Regex ($regex_string_and_options : string[]...) {
    
    my $regex_string = $regex_string_and_options->[0];
    my $options = (string)undef;
    if (@$regex_string_and_options > 1) {
      $options = $regex_string_and_options->[1];
    }
    
    my $self = Regex->new_with_options($regex_string, $options);
    
    return $self;
  }

  static method new_with_options : Regex ($regex_string : string, $option_chars : string) {
    my $self = Regex->_new_without_compile();
    
    if ($option_chars) {
      my $options_h = Hash->new({});
      
      my $option_chars_length = length $option_chars;
      for (my $i = 0; $i < $option_chars_length; $i++) {
        my $option_char = $option_chars->[$i];
        if ($option_char == 's') {
          my $found = $options_h->get("s");
          if ($found) {
            die "s option must be used once";
          }
          $self->{single_line_mode} = 1;
          $options_h->set_int("s" => 1);
        }
        elsif ($option_char == 'a') {
          my $found = $options_h->get("a");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ascii_mode} = 1;
          $options_h->set_int("a" => 1);
        }
        elsif ($option_char == 'i') {
          my $found = $options_h->get("i");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ignore_case} = 1;
          $options_h->set_int("i" => 1);
        }
      }
    }
    
    $self->compile($regex_string);
    
    return $self;
  }
  
  private static method _new_without_compile : Regex () {
    my $self = new Regex;
    
    $self->{patterns} = List->new_len(new Regex::Pattern[0], 0);

    $self->{captures} = new string[256];
    
    return $self;
  }
  
  private method compile : void ($regex_string : string) {
    
    unless ($regex_string) {
      die "Regex string must be defined";
    }
    
    my $regex_string_length = length $regex_string;
    
    if ($regex_string_length == 0) {
      die "Regex string must have length";
    }
    
    my $pos = 0;
    my $patterns = $self->{patterns};
    
    my $quantifier_min_str = "";
    my $quantifier_max_str = "";
    
    my $quantifier_status = &QUANTIFIER_STATUS_NOT_STARTED;
    
    my $char_class_negate = 0;
    
    my $is_capture = 0;
    my $pattern_capture_begin = 0;
    
    my $cur_code_point_ranges_list = IntList->new;
    
    my $char_class_parsing = 0;
    my $quantifier_parsing = 0;
    while ((my $code_point = Unicode->uchar($regex_string, \$pos)) >= 0) {
      
      my $before_is_hyphen = $self->{before_is_hyphen};
      $self->{before_is_hyphen} = 0;

      my $before_is_open_bracket = $self->{before_is_open_bracket};
      $self->{before_is_open_bracket} = 0;
      
      my $finish_code_point_ranges = 0;
      
      switch ($code_point) {
        case '\\': {
          my $next_code_point = Unicode->uchar($regex_string, \$pos);
          if ($code_point < 0) {
            die "Invalid regex. Last is \\ ";
          }
          
          switch ($next_code_point) {
            case 'd': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'0', '9'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\d must be used with ascii option";
              }
              break;
            }
            case 'D': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9']);
                
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\D must be used with ascii option";
              }
              break;
            }
            case 'w': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\w  must be used with ascii option";
              }
              break;
            }
            case 'W': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\W must be used with ascii option";
              }
              break;
            }
            case 's': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' '];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\s must be used with ascii option";
              }
              break;
            }
            case 'S': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' ']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\S must be used with ascii option";
              }
              break;
            }
            default: {
              if (Fn->is_perl_word($next_code_point)) {
                die "Invalid regex escape character";
              }
              # \: \- etc
              else {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)$next_code_point, $next_code_point];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
            }
          }
          
          break;
        }
        default: {
          # Charcter class
          if ($char_class_parsing) {
            if ($code_point == ']') {
              $char_class_parsing = 0;
              $finish_code_point_ranges = 1;
            }
            elsif ($code_point == '-') {
              my $cur_code_point_range = ['-', '-'];
              for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
              }
              $self->{before_is_hyphen} = 1;
            }
            else {
              # Charcater class negate
              if ($before_is_open_bracket && $code_point == '^') {
                $char_class_negate = 1;
              }
              else {
                if ($before_is_hyphen) {
                  # Pop '-'
                  $cur_code_point_ranges_list->pop;
                  $cur_code_point_ranges_list->pop;
                  
                  # Set max code point
                  $cur_code_point_ranges_list->set($cur_code_point_ranges_list->length - 1, $code_point);
                  
                  # Check min-max range
                  my $min = $cur_code_point_ranges_list->get($cur_code_point_ranges_list->length - 2);
                  my $max = $cur_code_point_ranges_list->get($cur_code_point_ranges_list->length - 1);
                  if ($min > $max) {
                    die "Invalid [] range";
                  }
                }
                else {
                  my $cur_code_point_range = [$code_point, $code_point];
                  for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                    $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                  }
                }
              }
            }
          }
          # Quantifier "{m,n}"
          elsif ($quantifier_parsing) {
            if ($code_point == '}') {
              unless ($quantifier_status == &QUANTIFIER_STATUS_MAX) {
                die "Invalid quantifier";
              }
              my $last_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
              if (length $quantifier_max_str == 0) {
                $last_pattern->{max_repeat} = Fn->INT32_MAX;
              }
              else {
                my $quantifier_max = Fn->to_int($quantifier_max_str);
                $last_pattern->{max_repeat} = $quantifier_max;
              }
              
              $quantifier_status = &QUANTIFIER_STATUS_NOT_STARTED;
              $quantifier_max_str = "";
              
              $quantifier_parsing = 0;
              break;
            }
            else {
              if ($quantifier_status == &QUANTIFIER_STATUS_MIN) {
                if (Fn->is_digit($code_point)) {
                  $quantifier_min_str .= $code_point - '0';
                }
                elsif ($code_point == ',') {
                  my $last_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                  if (length $quantifier_min_str == 0) {
                    $last_pattern->{min_repeat} = 0;
                  }
                  else {
                    my $quantifier_min = Fn->to_int($quantifier_min_str);
                    $last_pattern->{min_repeat} = $quantifier_min;
                  }
                  $quantifier_status = &QUANTIFIER_STATUS_MAX();
                  $quantifier_min_str .= "";
                }
                else {
                  die "Invalid quantifier";
                }
              }
              elsif ($quantifier_status == &QUANTIFIER_STATUS_MAX) {
                if (Fn->is_digit($code_point)) {
                  $quantifier_max_str .= $code_point - '0';
                }
                else {
                  die "Invalid quantifier";
                }
              }
            }
          }
          else {
            switch ($code_point) {
              case '^': {
                $self->{string_start} = 1;
                break;
              }
              case '.': {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = (int[])undef;
                if ($self->{single_line_mode}) {
                  $cur_code_point_range = [(int)0, 0xDFFF];
                }
                else {
                  $cur_code_point_range = $self->negate_code_point_ranges([(int)'\n', '\n']);
                }
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
                break;
              }
              case '$': {
                $self->{string_end} = 1;
                break;
              }
              case '|': {
                die "| is not supported";
                break;
              }
              case '(': {
                if ($is_capture) {
                  die "Invalid capture start";
                }
                else {
                  $is_capture = 1;
                  $pattern_capture_begin = 1;
                }
                break;
              }
              case ')': {
                if ($is_capture) {
                  $is_capture = 0;
                  my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                  $before_pattern->{capture_end} = 1;
                }
                else {
                  die "Invalid capture end";
                }
                break;
              }
              case '[': {
                $char_class_parsing = 1;
                $self->{before_is_open_bracket} = 1;
                break;
              }
              case '*': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 0;
                $before_pattern->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '+': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 1;
                $before_pattern->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '?': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 0;
                $before_pattern->{max_repeat} = 1;
                break;
              }
              case '{': {
                $quantifier_status = &QUANTIFIER_STATUS_MIN;
                $quantifier_parsing = 1;
                break;
              }
              default: {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [$code_point, $code_point];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
            }
          }
        }
      }

      if ($finish_code_point_ranges) {
        my $pattern = new Regex::Pattern;

        $pattern->{negate} = (byte)$char_class_negate;
        $pattern->{code_point_ranges} = $cur_code_point_ranges_list->to_array;
        
        $pattern->{max_repeat} = 1;
        $pattern->{min_repeat} = 1;

        if ($pattern_capture_begin) {
          $pattern->{capture_begin} = 1;
          $pattern_capture_begin = 0;
        }
        
        $patterns->push($pattern);
        
        $cur_code_point_ranges_list = IntList->new;
      }
    }
  }

  method match_offset : int ($string : string, $offset : int) {
    return $self->match_offset_v2($string, \$offset);
  }
  
  method match_offset_v2 : int ($string : string, $offset_ref : int*) {
    
    my $offset = $$offset_ref;
    
    unless ($string) {
      die "Target string must be defined";
    }
    
    my $patterns = $self->{patterns};
    my $patterns_length = $patterns->length;
    
    my $match_all = 0;
    my $string_index = 0;
    my $offset_before : int;
    my $ignore_case = $self->{ignore_case};
    while (1) {
      $offset_before = $offset;
      my $string_base_uchar = Unicode->uchar($string, \$offset);
      unless ($string_base_uchar >= 0) {
        last;
      }
      
      $string_index =  $offset_before;
      
      my $pattern_index = 0;
      
      my $pattern_capture_begin_index = -1;
      my $capture_count = 0;
      while (1) {
        my $pattern = (Regex::Pattern)$patterns->get($pattern_index);
        my $max_repeat = $pattern->{max_repeat};
        my $min_repeat = $pattern->{min_repeat};
        my $code_point_range = $pattern->{code_point_ranges};
        my $negate = $pattern->{negate};
        
        if ($pattern->{capture_begin}) {
          $pattern_capture_begin_index = $string_index;
        }
        
        my $string_before_index = $string_index;
        my $string_uchar = Unicode->uchar($string, \$string_index);
        unless ($string_uchar >= 0) {
          last;
        }
        
        
        my $match_repeat = 0;
        my $repeat_count = 0;
        my $repeat_before_target_index = $string_before_index;
        
        # Match uchar repeat
        for (my $repeat_index = 0; $repeat_index < $max_repeat; $repeat_index++) {
          # Match uchar
          my $match_char = 0;
          
          # Match a character
          for (my $min_max_index = 0; $min_max_index < @$code_point_range; $min_max_index += 2) {
            my $code_point_min = $code_point_range->[$min_max_index];
            my $code_point_max = $code_point_range->[$min_max_index + 1];
            
            # Match a code point
            if ($string_uchar >= $code_point_min && $string_uchar <= $code_point_max) {
              $match_char = 1;
            }
            
            unless ($match_char) {
              # Try ignore case
              if ($ignore_case) {
                my $string_uchar_reverse_case = -1;
                # a-z
                if ($string_uchar >= 0x61 && $string_uchar <= 0x7A) {
                  $string_uchar_reverse_case = $string_uchar - 32;
                }
                # A-Z
                elsif ($string_uchar >= 0x41 && $string_uchar <= 0x5A) {
                  $string_uchar_reverse_case = $string_uchar + 32;
                }
                
                if ($string_uchar_reverse_case >= 0) {
                  if ($string_uchar_reverse_case >= $code_point_min && $string_uchar_reverse_case <= $code_point_max) {
                    $match_char = 1;
                  }
                }
              }
            }
            
            if ($match_char) {
              last;
            }
          }
          
          # Negate
          if ($negate) {
            $match_char = !$match_char;
          }
          
          # Increment repeat count
          if ($match_char) {
            $repeat_count++;
            $repeat_before_target_index = $string_index;

            if ($string_index == length $string) {
              last;
            }
            
            $string_uchar = Unicode->uchar($string, \$string_index);
            
            $string_before_index = $string_index;
          }
          else {
            last;
          }
        }
        if ($repeat_count >= $min_repeat) {
          $match_repeat = 1;
        }
        
        if ($match_repeat) {
          if ($pattern->{capture_end}) {
            $self->{captures}[$capture_count] = Fn->substr($string, $pattern_capture_begin_index, $repeat_before_target_index - $pattern_capture_begin_index);
            $capture_count++;
            if ($capture_count > 255) {
              die "Too many captures";
            }
          }
          $pattern_index++;
          $string_index = $repeat_before_target_index;
          if ($pattern_index == $patterns_length) {
            last;
          }
        }
        else {
          last;
        }
      }
      
      if ($pattern_index == $patterns_length) {
        $match_all = 1;
        last;
      }
      else {
        if ($self->{string_start}) {
          last;
        }
      }
    }
    
    my $really_match = 0;
    if ($match_all) {
      if ($self->{string_end}) {
        if ($string_index == length $string) {
          $really_match = 1;
        }
      }
      else {
        $really_match = 1;
      }
    }
    
    if ($really_match) {
      $self->{match_start} = $offset_before;
      $self->{match_length} = $string_index - $self->{match_start};
    }
    
    return $really_match;
  }
  
  method replace  : string ($string : string, $string_offset : int, $replace : string) {
    return $self->replace_opt($string, $string_offset, $replace, {replace_all => 0});
  }

  method replace_cb  : string ($string : string, $string_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($string, $string_offset, $replace_cb, {replace_all => 0});
  }

  method replace_all  : string ($string : string, $string_offset : int, $replace : string) {
    return $self->replace_opt($string, $string_offset, $replace, {replace_all => 1});
  }

  method replace_all_cb  : string ($string : string, $string_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($string, $string_offset, $replace_cb, {replace_all => 1});
  }
  
  private method replace_opt  : string ($string : string, $offset : int, $replace_object : object, $options : object[]) {
    
    my $opt = Hash->new($options);
    
    my $original_target_base_index = $offset;
    
    my $replace_all = 0;
    if (my $replace_all_obj = $opt->get("replace_all")) {
      $replace_all = (int)$replace_all_obj;
    }
    $self->{replace_count} = 0;
    
    unless ($string) {
      return $string;
    }
    
    my $result : string;
    my $replace_count = 0;
    my $result_buffer = StringBuffer->new;
    my $tarlength = length $string;
    
    if ($offset > 0) {
      my $first_string = Fn->substr($string, 0, $offset);
      $result_buffer->push($first_string);
    }
    
    while (my $match = $self->match_offset($string, $offset)) {
      
      my $match_start = $self->match_start;
      my $match_end = $match_start + $self->match_length;
      
      my $replace : string;
      if ($replace_object isa string) {
        $replace = (string)$replace_object;
      }
      elsif ($replace_object isa object[]) {
        
        my $replace_objects = (object[])$replace_object;
        
        my $replace_buffer = StringBuffer->new;
        for (my $i = 0; $i < @$replace_objects; $i++) {
          my $replace_elem_object = $replace_objects->[$i];
          
          if ($replace_elem_object isa string) {
            $replace_buffer->push((string)$replace_elem_object);
          }
          elsif ($replace_elem_object isa Int) {
            my $capture = $self->captures->[(int)$replace_elem_object];
            $replace_buffer->push($capture);
          }
          else {
            die "Invalid replace argument element";
          }
        }
        
        $replace = $replace_buffer->to_string;
      }
      elsif ($replace_object isa Regex::Replacer) {
        my $replace_buffer = StringBuffer->new;
        my $replacer = (Regex::Replacer)$replace_object;
        my $cb_result = $replacer->($self);
        $replace_buffer->push($cb_result);
        $replace = $replace_buffer->to_string;
      }
      else {
        die "Invalid replace argument";
      }
      
      my $match_length = $self->match_length;
      my $replace_length = length $replace;
      
      my $result_length = $tarlength + $replace_length - $match_length;
      
      $result = (mutable string)new_string_len($result_length);
      
      my $rest_length = $tarlength - $match_end;
      
      my $before_result = (mutable string)Fn->substr($string, $offset, $match_start - $offset);
      $result_buffer->push($before_result);
      $result_buffer->push($replace);
      
      $replace_count++;
      
      unless ($replace_all) {
        last;
      }
      $offset = $match_end;
    }
    
    
    if ($replace_count == 0) {
      $result = Fn->copy_string($string);
    }
    else {
      my $match_end = $self->match_start + $self->match_length;
      my $rest_length = $tarlength - $match_end;
      
      if ($rest_length > 0) {
        my $rest_string = Fn->substr($string, $match_end, $rest_length);
        $result_buffer->push($rest_string);
      }
      
      $result = $result_buffer->to_string;
    }
    
    $self->{replace_count} = $replace_count;
    
    return $result;
  }
  
  method cap1 : string () { return $self->captures->[0]; }
  method cap2 : string () { return $self->captures->[1]; }
  method cap3 : string () { return $self->captures->[2]; }
  method cap4 : string () { return $self->captures->[3]; }
  method cap5 : string () { return $self->captures->[4]; }
  method cap6 : string () { return $self->captures->[5]; }
  method cap7 : string () { return $self->captures->[6]; }
  method cap8 : string () { return $self->captures->[7]; }
  method cap9 : string () { return $self->captures->[8]; }
  method cap10 : string () { return $self->captures->[9]; }

  private method culcurate_code_point_ranges : int[] ($code_point_raw_ranges_list : IntList) {
    my $code_point_ranges_list = IntList->new;
    for (my $i = 0; $i < $code_point_raw_ranges_list->length; $i++) {
      my $value = $code_point_raw_ranges_list->get($i);
      if ($value >= 0) {
        $code_point_ranges_list->push($value);
      }
    }
    
    return $code_point_ranges_list->to_array;
  }

  private method negate_code_point_ranges : int[] ($code_point_ranges : int[]) {
    
    if (@$code_point_ranges < 2) {
      die "The length of the code point rainges must be more than 2";
    }

    my $negate_code_point_rainges_raw_list = IntList->new;
    $negate_code_point_rainges_raw_list->push(0);
    for (my $i = 0; $i < @$code_point_ranges; $i += 2) {
      my $min = $code_point_ranges->[$i];
      my $max = $code_point_ranges->[$i + 1];
      $negate_code_point_rainges_raw_list->push($min - 1);
      $negate_code_point_rainges_raw_list->push($max + 1);
    }
    $negate_code_point_rainges_raw_list->push(0x10FFFF);

    my $cur_max = 0;
    my $negate_code_point_rainges_list = IntList->new;
    for (my $i = 0; $i < $negate_code_point_rainges_raw_list->length; $i += 2) {
      my $min = $negate_code_point_rainges_raw_list->get($i);
      my $max = $negate_code_point_rainges_raw_list->get($i + 1);
      unless ($min > $max) {
        $negate_code_point_rainges_list->push($min);
        $negate_code_point_rainges_list->push($max);
      }
    }
    
    my $negate_code_point_rainges = $negate_code_point_rainges_list->to_array;

    return $negate_code_point_rainges;
  }

}

